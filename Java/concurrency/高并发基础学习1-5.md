## 并发
同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。  
多个线程操作相同的资源，保证线程安全，合理使用资源
 
*** 
## 高并发
高并发是互联网分布式架构设计中必须要考虑的因素，通常指，通过设计保证系统能够同时并行处理很多请求。  
服务能同时处理很多请求，提高程序性能

***
## java内存模型（JMM）
JMM是一种规范，规定了java虚拟机与计算机内存是如何协同工作的。规定了一个线程是如何和何时可以看到其它线程修改过的共享变量的知识以及在必须时如何同步地访问共享变量.

* 堆（heap）：堆是一个运行时的数据区，由垃圾回收来负责的

![内存模型](http://118.126.64.234:10022/daimonster/Images/raw/01c1aefe02a175d6eff74f180fe094137871be66/Java-high-concurrency/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

* 同步的八种规则

***
## 并发模拟
* Postman http请求工具
* Apache Bench Apache附带的工具，测试网站性能
* Jmeter Apache组织开发的压力测试工具
* 代码：Semaphore、CountDownLatch等

***
## 线程安全性
* 定义： 当多个线程访问某个类时候，不管运行时采用何种调度方式或者这些进程如何交替执行，并且在主调代码中不需要任何额外的同步活协同，这个类都能表现出正确的行为，那么就成这个类是安全的。

主要体现在三个方面：
* 原子性：提供了互斥访问，同一时刻只能有一个线程对它来进行操作。可以使用Atomic和锁
    * AtomicXXX：CAS，unsafe.compareAndSwapXXX
        atomic包里面调用了unsafe包，unsafe包里面getAndAddInt这个调用了compareAndSwapXXX（CAS）这个方法。
        * count值： 工作内存的值
        * 底层值： 主内存的值
    * AtomicLong(性能差，准确的数据的时候使用)、LongAdder（性能好，优先使用）
    * AtomicBoolean compareAndSet
    * AtomicReference、AtomicReferenceFieldUpdater
        * AtomicIntegerFieldUpdater: 原子性地更新某个类的实例中的某个字段
    * AtomicStampReference: CAS的ABA问题
    * AtomicLongArray: 维护一个AtomicLong数组，相比于AtomicLong，能够更新索引对应的值

    * 锁
        * synchronized:依赖JVM（作用对象的作用范围内） 同步锁，修饰的对象有下面四种：
            * 修饰代码块：大括号括起来的代码，作用于调用的对象
            * 修饰方法：整个方法，作用于调用对象
            * 修饰静态方法：整个静态方法，作用于这个类的**所有**对象
            * 修饰类：括号括起来的部分，作用于**所有**对象
            * 子类继承父类带有synchronized的方法的时候，是不带sync关键字的
        * Lock：依赖特殊的cpu指令，代码实现，ReentrantLock

    * 对比：
        * synchronized:不可中断锁，适合竞争不激烈，可读性好
        * lock：可中断锁，多样化同步，竞争激烈时能维持常态
        * Atomic：竞争激烈时能维持常态，比lock性能好；只能同步一个值        
* 可见性：一个线程对主内存的修改可以及时地被其他线程观察到。
    * 导致共享变量在线程间不可见的原因：
        1. 线程交叉执行
        2. 重排序结合线程交叉执行
        3. 共享变量更新后的值没有在工作内存与主内存之间及时更新
    * JVM关于synchronized的两条规定：
        1. 线程解锁前，必须把共享变量的最新值刷新到主内存
        1. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁和解锁是同一把锁）
    * volatile
        通过加入内存屏障和禁止重排序优化来实现  
        * 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
        * 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
        * volatile 写： 普通读-普通写-StoreStore屏障-Volatile写-StoreLoad屏障
        * volatile 特别适合作为状态标记量： 标记线程应该做的初始化是否完成
* 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般无序
    * Java内存模型中，允许编译器和内存模型对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性
    * volatile，synchronized，lock 保证有序性 synchronized，lock能够保证每个时刻有一个线程执行同步代码，让线程循序执行同步代码。
    * hanppends-before原则
        * 程序次序规则：一个线程内，按照代码的顺序，书写在前面的操作先行发生于书写在后面的操作：无法保证程序在多线程中指令执行的顺序性
        * 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作

***
## 线程封闭
将对象封装到一个线程里面，即使对象线程不安全，也只有这一个线程能看到  
### 实现方法
* Ad-hoc 线程封闭：程序控制实现，最糟糕，忽略
* 堆栈封闭：局部变量，无并发问题
* ThreadLocal 线程封闭：特别好的封闭方法

***
## 常见的线程不安全类与写法
* StringBuilder(线程不安全)和StringBuffer（线程安全）
* SimpleDateFormat->JodaTime
* ArrayList,HashSet,HashMap等Collections 都线程不安全
* 先检查再执行：if(condition(a)) {handle(a);} // 线程不安全，有可能检查条件的时候没问题，多个线程处理的时候出现问题， 必须加锁或者保证是原子性的

***
## 线程安全-同步容器
* ArrayList -> Vector,Stack(继承vector类)
    * 也有线程不安全的时候
* HashMap -> HashTable(key,value 不能为null)
* Collections.synchronizedXXX(List,Set,Map)
* 在使用foreach循环或者迭代器循环的时候，尽量不要在操作过程中做增加删除等更新操作，如果一定要做，就先标记元素，循环之后进行操作

***
## 安全共享对象策略
* 线程限制：一个被线程限制的对象,由线程独占，并且只能被占有它的线程修改。
* 共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它。
* 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其他线程无需通过额外的同步就可以通过公共接口随意访问它
* 被守护对象：被守护对象只能通过获取特定的锁来访问。