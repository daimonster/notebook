## 事务
### ACID 特性：

* Atomicity ：要么全做，要么不做
* Consistency: 约束 不仅仅是数据库物理上的约束，而且逻辑上的假设，也必须是成立的。
* Isolation：隔离性 事务之间必须是相互独立，互不影响
* Durability: 持久性 事务昨晚之后，数据能够持久下去
### 事务的隔离级别
* DEFAULT： 使用后端数据库默认的隔离级别  
* READ_UNCOMMITED：允许你读取还未提交的改变了的数据。可能导致脏、幻、不可重复读  
* READ_COMMITED：允许并发事务已经提交后读取。可防止脏读，但幻、不可重复仍可能发生。  
* REPEATABLE_READ: 对相同字段的读取是一致的，除非数据被事务本身改变，反正脏、不可重复，幻读能发生  
* SERIALIZABLE: 完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及到数据表来完成的 

### 脏读、不可重复读、幻读：
也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：  

* 脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。  

也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。  

* 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。

也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。  

* 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。  

也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。

### 不可重复读和幻读比较：
两者有些相似，但是前者针对的是update或delete，后者针对的insert。


## 乐观锁
* 读取数据的时候，记录timestamp
* 修改数据
* 检查和提交数据

## 数据库常见问题
### 范式
* 第一范式（1NF）：所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

* 第二范式：在第一范式的基础上，要求实体的属性完全依赖于主关键字。

* 第三范式：2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）